import { Component, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, Optional, Output, Renderer2 } from '@angular/core';
import { Http, HttpModule } from '@angular/http';
import 'rxjs/add/operator/map';
import { CommonModule } from '@angular/common';
import isRetina from 'is-retina';
import { Md5 } from 'ts-md5/dist/md5';

/**
 * Token used to inject the AvatarConfig object
 */
var AVATAR_CONFIG = new InjectionToken('avatar.config');

/**
 * Represents avatar configuration Object.
 */
var AvatarConfig = (function () {
    /**
     * @param {?=} avatarColors
     */
    function AvatarConfig(avatarColors) {
        this.avatarColors = avatarColors;
    }
    return AvatarConfig;
}());

/**
 * list of Supported avatar sources
 */
var sources = [
    "FACEBOOK",
    "GOOGLE",
    "TWITTER",
    "VKONTAKTE",
    "SKYPE",
    "GRAVATAR",
    "GITHUB",
    "CUSTOM",
    "INITIALS",
    "VALUE"
];
/**
 * list of default colors
 */
var defaultColors = [
    "#1abc9c",
    "#3498db",
    "#f1c40f",
    "#8e44ad",
    "#e74c3c",
    "#d35400",
    "#2c3e50",
    "#7f8c8d"
];
/**
 * Provides utilities methods related to Avatar component
 */
var AvatarService = (function () {
    /**
     * @param {?} avatarConfig
     * @param {?} http
     */
    function AvatarService(avatarConfig, http) {
        this.avatarConfig = avatarConfig;
        this.http = http;
    }
    /**
     * Get a random color.
    The color is based on the ascii code of the given value.
    This will guarantee that avatars with the same value
    will have the same background color
    
    \@returns {string}
     * @param {?} value
     * @return {?}
     */
    AvatarService.prototype.getRandomColor = function (value) {
        if (!value)
            return 'transparent';
        var /** @type {?} */ asciiCodeSum = this._calculateAsciiCode(value);
        var /** @type {?} */ colors = this.getAvatarColors();
        return colors[asciiCodeSum % colors.length];
    };
    /**
     * Returns the list of supported avatar sources.
    
    \@returns {string[]}
     * @return {?}
     */
    AvatarService.prototype.getSources = function () {
        return sources;
    };
    /**
     * Returns the list of defaul colors.
    
    \@returns {string[]}
     * @return {?}
     */
    AvatarService.prototype.getDefaultColors = function () {
        return defaultColors;
    };
    /**
     * Returns a set of colors that will be used to fill the background color
    of text avatars. If the user has provided a list of colors, Then this list
    will be returned. Otherwise, the default colors will be used.
    
    \@returns {string[]}
     * @return {?}
     */
    AvatarService.prototype.getAvatarColors = function () {
        if (this.avatarConfig && this.avatarConfig.avatarColors && this.avatarConfig.avatarColors.length > 0) {
            return this.avatarConfig.avatarColors;
        }
        return this.getDefaultColors();
    };
    /**
     * Get source priority
    Facebook has the highest priority, Value has the lowest
    \@param source
    \@param avatarSources
     * @param {?} source
     * @param {?=} avatarSources
     * @return {?}
     */
    AvatarService.prototype.getSourcePriority = function (source, avatarSources) {
        if (avatarSources === void 0) { avatarSources = sources; }
        return sources.indexOf(source.toUpperCase());
    };
    /**
     * Check if the given source is a valid avatar source or not.
    
    \@export
    \@param {string} source
    \@returns {boolean}
     * @param {?} source
     * @return {?}
     */
    AvatarService.prototype.isSource = function (source) {
        return sources.findIndex(function (item) { return item === source.toUpperCase(); }) > -1;
    };
    /**
     * return the sum of ascii code of the given string
    \@param value
     * @param {?} value
     * @return {?}
     */
    AvatarService.prototype._calculateAsciiCode = function (value) {
        return value.split('').map(function (letter) { return letter.charCodeAt(0); })
            .reduce(function (previous, current) { return previous + current; });
    };
    /**
     * Check wether the type of avatar is text or not.
    
    \@export
    \@param {string} sourceType
    \@returns {boolean}
     * @param {?} sourceType
     * @return {?}
     */
    AvatarService.prototype.isTextAvatar = function (sourceType) {
        return ["INITIALS", "VALUE"].indexOf(sourceType) > -1;
    };
    /**
     * Retuns an Observable which is responisble of fetching async avatars
    \@param {avatarUrl} url of the avatar
    \@return {Observable} of json data
     * @param {?} avatarUrl
     * @return {?}
     */
    AvatarService.prototype.fetchAvatar = function (avatarUrl) {
        return this.http.get(avatarUrl).map(function (response) { return response.json(); });
    };
    return AvatarService;
}());
AvatarService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
AvatarService.ctorParameters = function () { return [
    { type: AvatarConfig, decorators: [{ type: Optional }, { type: Inject, args: [AVATAR_CONFIG,] },] },
    { type: Http, },
]; };

/**
 * Contract of all async sources.
Every async source must implement the processResponse method that extracts the avatar url from the data
\@interface AsyncSource
 * @abstract
 */
var AsyncSource = (function () {
    /**
     * @param {?} sourceId
     */
    function AsyncSource(sourceId) {
        this.sourceId = sourceId;
    }
    /**
     * @abstract
     * @param {?=} size
     * @return {?}
     */
    AsyncSource.prototype.getAvatar = function (size) { };
    /**
     * @abstract
     * @param {?} data
     * @param {?=} size
     * @return {?}
     */
    AsyncSource.prototype.processResponse = function (data, size) { };
    return AsyncSource;
}());

/**
 *  Facebook source impelementation.
 Fetch avatar source based on facebook identifier
 and image size

\@export
\@class Facebook
\@implements {Source}
 */
var Facebook = (function () {
    /**
     * @param {?} sourceId
     */
    function Facebook(sourceId) {
        this.sourceId = sourceId;
        this.sourceType = "FACEBOOK";
    }
    /**
     * @param {?} size
     * @return {?}
     */
    Facebook.prototype.getAvatar = function (size) {
        return 'https://graph.facebook.com/' +
            (this.sourceId + "/picture?width=" + size + "&height=" + size);
    };
    return Facebook;
}());

/**
 *  Twitter source impelementation.
 Fetch avatar source based on google identifier
 and image size

\@export
\@class Twitter
\@implements {Source}
 */
var Twitter = (function () {
    /**
     * @param {?} sourceId
     */
    function Twitter(sourceId) {
        this.sourceId = sourceId;
        this.sourceType = "TWITTER";
    }
    /**
     * @param {?} size
     * @return {?}
     */
    Twitter.prototype.getAvatar = function (size) {
        var /** @type {?} */ twitterImgSize = this._getImageSize(size);
        return "https://twitter.com/" + this.sourceId + "/profile_image?size=" + twitterImgSize;
    };
    /**
     * @param {?} size
     * @return {?}
     */
    Twitter.prototype._getImageSize = function (size) {
        if (size <= 24)
            return 'mini';
        if (size <= 48)
            return 'normal';
        if (size <= 73)
            return 'bigger';
        return 'original';
    };
    return Twitter;
}());

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 *  Google source impelementation.
 Fetch avatar source based on google identifier
 and image size

\@export
\@class Google
\@implements {AsyncSource}
 */
var Google = (function (_super) {
    __extends(Google, _super);
    /**
     * @param {?} sourceId
     */
    function Google(sourceId) {
        var _this = _super.call(this, sourceId) || this;
        _this.sourceType = "GOOGLE";
        return _this;
    }
    /**
     * @return {?}
     */
    Google.prototype.getAvatar = function () {
        return "https://picasaweb.google.com/data/entry/api/user/" + this.sourceId + "?alt=json";
    };
    /**
     * Extract google avatar from json data
    
    \@param {*} data
    \@returns
    \@memberof Google
     * @param {?} data
     * @param {?=} size
     * @return {?}
     */
    Google.prototype.processResponse = function (data, size) {
        var /** @type {?} */ avatarSrc = data.entry.gphoto$thumbnail.$t;
        if (avatarSrc) {
            return avatarSrc.replace('s64', 's' + size);
        }
    };
    return Google;
}(AsyncSource));

/**
 *  Custom source impelementation.
 return custom image as an avatar

\@export
\@class Custom
\@implements {Source}
 */
var Custom = (function () {
    /**
     * @param {?} sourceId
     */
    function Custom(sourceId) {
        this.sourceId = sourceId;
        this.sourceType = "CUSTOM";
    }
    /**
     * @return {?}
     */
    Custom.prototype.getAvatar = function () {
        return this.sourceId;
    };
    return Custom;
}());

/**
 *  Initials source impelementation.
 return the initals of the given value

\@export
\@class Value
\@implements {Source}
 */
var Initials = (function () {
    /**
     * @param {?} sourceId
     */
    function Initials(sourceId) {
        this.sourceId = sourceId;
        this.sourceType = "INITIALS";
    }
    /**
     * @param {?} initialsSize
     * @return {?}
     */
    Initials.prototype.getAvatar = function (initialsSize) {
        return this._getInitials(this.sourceId, initialsSize);
    };
    /**
     * @param {?} name
     * @param {?} size
     * @return {?}
     */
    Initials.prototype._getInitials = function (name, size) {
        if (name) {
            var /** @type {?} */ initials = name.trim().split(" ");
            if (size && size < initials.length) {
                return this._constructInitials(initials.slice(0, size));
            }
            else {
                return this._constructInitials(initials);
            }
        }
        return "";
    };
    /**
     * @param {?} elements
     * @return {?}
     */
    Initials.prototype._constructInitials = function (elements) {
        if (elements && elements.length > 0) {
            return elements.filter(function (element) { return element && element.length > 0; })
                .map(function (element) { return element[0].toUpperCase(); }).join('');
        }
        return '';
    };
    return Initials;
}());

/**
 *  Gravatar source impelementation.
 Fetch avatar source based on gravatar email

\@export
\@class Gravatar
\@implements {Source}
 */
var Gravatar = (function () {
    /**
     * @param {?} value
     */
    function Gravatar(value) {
        this.value = value;
        this.sourceType = "GRAVATAR";
        this.sourceId = value.match('^[a-f0-9]{32}$') ? value : Md5.hashStr(value).toString();
    }
    /**
     * @param {?} size
     * @return {?}
     */
    Gravatar.prototype.getAvatar = function (size) {
        var /** @type {?} */ avatarSize = isRetina() ? size * 2 : size;
        return "https://secure.gravatar.com/avatar/" + this.sourceId + "?s=" + avatarSize + "&d=404";
    };
    return Gravatar;
}());

/**
 *  Skype source impelementation.
 Fetch avatar source based on skype identifier

\@export
\@class Skype
\@implements {Source}
 */
var Skype = (function () {
    /**
     * @param {?} sourceId
     */
    function Skype(sourceId) {
        this.sourceId = sourceId;
        this.sourceType = "SKYPE";
    }
    /**
     * @return {?}
     */
    Skype.prototype.getAvatar = function () {
        return "https://api.skype.com/users/" + this.sourceId + "/profile/avatar";
    };
    return Skype;
}());

/**
 *  Value source impelementation.
 return the value as avatar

\@export
\@class Value
\@implements {Source}
 */
var Value = (function () {
    /**
     * @param {?} sourceId
     */
    function Value(sourceId) {
        this.sourceId = sourceId;
        this.sourceType = "VALUE";
    }
    /**
     * @return {?}
     */
    Value.prototype.getAvatar = function () {
        return this.sourceId;
    };
    return Value;
}());

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 *  Vkontakte source impelementation.
 Fetch avatar source based on vkontakte identifier
 and image size

\@export
\@class Google
\@implements {AsyncSource}
 */
var apiVersion = 5.8;
var Vkontakte = (function (_super) {
    __extends$1(Vkontakte, _super);
    /**
     * @param {?} sourceId
     */
    function Vkontakte(sourceId) {
        var _this = _super.call(this, sourceId) || this;
        _this.sourceType = "VKONTAKTE";
        return _this;
    }
    /**
     * @param {?} size
     * @return {?}
     */
    Vkontakte.prototype.getAvatar = function (size) {
        var /** @type {?} */ imgSize = this._getImageSize(size);
        return "https://api.vk.com/method/users.get?user_id=" + this.sourceId + "&v=" + apiVersion + "&fields=" + imgSize;
    };
    /**
     * Returns image size related to vkontakte API
    \@param size
     * @param {?} size
     * @return {?}
     */
    Vkontakte.prototype._getImageSize = function (size) {
        if (size <= 50)
            return 'photo_50';
        if (size <= 100)
            return 'photo_100';
        if (size <= 200)
            return 'photo_200';
        return 'photo_max';
    };
    /**
     * extract vkontakte avatar from json data
    
    \@param {*} data
    \@returns
    \@memberof Vkontakte
     * @param {?} data
     * @return {?}
     */
    Vkontakte.prototype.processResponse = function (data) {
        // avatar key property is the size used to generate avatar url
        // size property is always the last key in the response object
        var /** @type {?} */ sizeProperty = Object.keys(data["response"][0]).pop();
        // return avatar src
        return data["response"][0][sizeProperty];
    };
    return Vkontakte;
}(AsyncSource));

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 *  Github source impelementation.
 Fetch avatar source based on github identifier

\@export
\@class Github
\@implements {AsyncSource}
 */
var Github = (function (_super) {
    __extends$2(Github, _super);
    /**
     * @param {?} sourceId
     */
    function Github(sourceId) {
        var _this = _super.call(this, sourceId) || this;
        _this.sourceType = "GITHUB";
        return _this;
    }
    /**
     * @return {?}
     */
    Github.prototype.getAvatar = function () {
        return "https://api.github.com/users/" + this.sourceId;
    };
    /**
     * extract github avatar from json data
    
    \@param {*} data The data returned from the souce API
    \@param {number} size The size of the image requested
    \@returns url of the github avatar icon
    \@memberof AvatarComponent
     * @param {?} data
     * @param {?=} size
     * @return {?}
     */
    Github.prototype.processResponse = function (data, size) {
        if (size) {
            return data.avatar_url + "&s=" + size;
        }
        return data.avatar_url;
    };
    return Github;
}(AsyncSource));

/**
 * Factory class that implements factory method pattern.
Used to create Source implementation class based
on the source Type

\@export
\@class SourceFactory
 */
var SourceFactory = (function () {
    function SourceFactory() {
        this._sources = {};
        this._sources['facebook'] = Facebook;
        this._sources['twitter'] = Twitter;
        this._sources['google'] = Google;
        this._sources['skype'] = Skype;
        this._sources['gravatar'] = Gravatar;
        this._sources['custom'] = Custom;
        this._sources['initials'] = Initials;
        this._sources['value'] = Value;
        this._sources['vkontakte'] = Vkontakte;
        this._sources['github'] = Github;
    }
    /**
     * @param {?} sourceType
     * @param {?} sourceValue
     * @return {?}
     */
    SourceFactory.prototype.newInstance = function (sourceType, sourceValue) {
        return new this._sources[sourceType](sourceValue);
    };
    return SourceFactory;
}());
SourceFactory.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
SourceFactory.ctorParameters = function () { return []; };

var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
/**
 * Universal avatar component that
generates avatar from different sources

\@export
\@class AvatarComponent
\@implements {OnInit}
 */
var AvatarComponent = (function () {
    /**
     * @param {?} renderer
     * @param {?} elementRef
     * @param {?} sourceFactory
     * @param {?} avatarService
     */
    function AvatarComponent(renderer, elementRef, sourceFactory, avatarService) {
        var _this = this;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.sourceFactory = sourceFactory;
        this.avatarService = avatarService;
        this.round = true;
        this.size = 50;
        this.textSizeRatio = 3;
        this.fgColor = "#FFF";
        this.style = {};
        this.cornerRadius = 0;
        this.clickOnAvatar = new EventEmitter();
        this._currentSource = 0;
        this._sources = Array();
        this.avatarStyle = {};
        this.hostStyle = {};
        // listen to click events on the root element
        this.renderer.listen(this.elementRef.nativeElement, "click", function (event) {
            _this.clickOnAvatar.emit(_this._sources[_this._currentSource - 1]);
        });
    }
    /**
     * Detect inputs change
    
    \@param {{ [propKey: string]: SimpleChange }} changes
    
    \@memberof AvatarComponent
     * @param {?} changes
     * @return {?}
     */
    AvatarComponent.prototype.ngOnChanges = function (changes) {
        for (var /** @type {?} */ propName in changes) {
            if (this.avatarService.isSource(propName)) {
                var /** @type {?} */ currentValue = changes[propName].currentValue;
                this._addSource(propName, currentValue);
            }
        }
        // reintialize the avatar component when a source property value has changed
        // the fallback system must be re-invoked with the new values.
        this._initializeAvatar();
    };
    /**
     * Initialize the avatar component and its fallback system
     * @return {?}
     */
    AvatarComponent.prototype._initializeAvatar = function () {
        var _this = this;
        this._currentSource = 0;
        if (this._sources.length > 0 && this._sources[this._currentSource]) {
            // Order sources array by source priority
            this._sources.sort(function (leftSide, rightSide) {
                return _this.avatarService.getSourcePriority(leftSide.sourceId) - _this.avatarService.getSourcePriority(rightSide.sourceId);
            });
            // Host style 
            this.hostStyle = {
                width: this.size + 'px',
                height: this.size + 'px'
            };
            // Fetch avatar source
            this.fetch();
        }
    };
    /**
     * Fetch avatar source
    
    \@param {any} event
    
    \@memberOf AvatarComponent
     * @param {?=} event
     * @return {?}
     */
    AvatarComponent.prototype.fetch = function (event) {
        var /** @type {?} */ avatarSource = this._sources[this._currentSource];
        if (this.avatarService.isTextAvatar(avatarSource.sourceType)) {
            this.data = avatarSource.getAvatar(this.initialsSize);
            this.src = undefined;
            this.avatarStyle = this._initialsStyle(avatarSource.sourceId);
        }
        else {
            this.avatarStyle = this._imageStyle();
            if (avatarSource instanceof AsyncSource) {
                this._fetchAsyncAvatar(avatarSource);
            }
            else {
                this.src = avatarSource.getAvatar(this.size);
            }
        }
        this._currentSource++;
    };
    /**
     *
    \@returns initials style
    
    \@memberOf AvatarComponent
     * @param {?} avatarValue
     * @return {?}
     */
    AvatarComponent.prototype._initialsStyle = function (avatarValue) {
        return __assign({ textAlign: 'center', borderRadius: this.round ? '100%' : this.cornerRadius + 'px', border: this.borderColor ? '1px solid ' + this.borderColor : '', textTransform: 'uppercase', color: this.fgColor, backgroundColor: this.bgColor ? this.bgColor : this.avatarService.getRandomColor(avatarValue), font: Math.floor(this.size / this.textSizeRatio) + 'px Helvetica, Arial, sans-serif', lineHeight: this.size + 'px' }, this.style);
    };
    /**
     *
    \@returns image style
    
    \@memberOf AvatarComponent
     * @return {?}
     */
    AvatarComponent.prototype._imageStyle = function () {
        return __assign({ maxWidth: '100%', borderRadius: this.round ? '50%' : this.cornerRadius + 'px', border: this.borderColor ? '1px solid ' + this.borderColor : '', width: this.size, height: this.size }, this.style);
    };
    /**
     * Fetch avatar image asynchrounsly.
    
    \@param {Source} source represents avatar source
    \@memberof AvatarComponent
     * @param {?} source
     * @return {?}
     */
    AvatarComponent.prototype._fetchAsyncAvatar = function (source) {
        var _this = this;
        this.avatarService.fetchAvatar(source.getAvatar()).subscribe(function (data) {
            // extract avatar image from the response data
            _this.src = source.processResponse(data, _this.size);
        }, function (err) {
            console.error("ngx-avatar: error while fetching " + source.sourceType + " avatar ");
        });
    };
    /**
     * Add avatar source
    
    \@param sourceType avatar source type e.g facebook,twitter, etc.
    \@param sourceValue  source value e.g facebookId value, etc.
     * @param {?} sourceType
     * @param {?} sourceValue
     * @return {?}
     */
    AvatarComponent.prototype._addSource = function (sourceType, sourceValue) {
        if (sourceValue) {
            if (!this._updateExistingSource(sourceType, sourceValue)) {
                this._sources.push(this.sourceFactory.newInstance(sourceType, sourceValue));
            }
        }
    };
    /**
     * This method check wether an avatar source has been added. If so
    the source value will be updated with the new value passed as
    paramater.
    It returns true if the source exists and update has been performed,
    returns false if the source was not found
    
    \@param {string} sourceType the type of the source
    \@param {string} sourceValue the new value of the source
    
    \@memberof AvatarComponent
     * @param {?} sourceType
     * @param {?} sourceValue
     * @return {?}
     */
    AvatarComponent.prototype._updateExistingSource = function (sourceType, sourceValue) {
        var /** @type {?} */ sourceIndex = this._sources.findIndex(function (source) { return source.sourceType === sourceType.toUpperCase(); });
        if (sourceIndex > -1) {
            this._sources[sourceIndex].sourceId = sourceValue;
            return true;
        }
        return false;
    };
    return AvatarComponent;
}());
AvatarComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-avatar',
                styles: ["\n  :host{\n    border-radius: \"50%\";\n  }\n  "],
                template: "\n    <div class=\"avatar-container\" [ngStyle]=\"hostStyle\">\n    <img *ngIf=\"src\"\n      [src]=\"src\"\n      [width]=\"size\"\n      [height]=\"size\"\n      [ngStyle]=\"avatarStyle\"\n      (error)=\"fetch($event)\"\n      class=\"avatar-content\"\n     />\n   \n   <div *ngIf=\"data && !src\"\n     [ngStyle]=\"avatarStyle\"\n     class=\"avatar-content\">{{data}}</div>\n   </div>"
            },] },
];
/**
 * @nocollapse
 */
AvatarComponent.ctorParameters = function () { return [
    { type: Renderer2, },
    { type: ElementRef, },
    { type: SourceFactory, },
    { type: AvatarService, },
]; };
AvatarComponent.propDecorators = {
    'round': [{ type: Input },],
    'size': [{ type: Input },],
    'textSizeRatio': [{ type: Input },],
    'bgColor': [{ type: Input },],
    'fgColor': [{ type: Input },],
    'borderColor': [{ type: Input },],
    'style': [{ type: Input },],
    'cornerRadius': [{ type: Input },],
    'facebook': [{ type: Input, args: ['facebookId',] },],
    'twitter': [{ type: Input, args: ['twitterId',] },],
    'google': [{ type: Input, args: ['googleId',] },],
    'vkontakte': [{ type: Input, args: ['vkontakteId',] },],
    'skype': [{ type: Input, args: ['skypeId',] },],
    'gravatar': [{ type: Input, args: ['gravatarId',] },],
    'github': [{ type: Input, args: ['githubId',] },],
    'custom': [{ type: Input, args: ['src',] },],
    'initials': [{ type: Input, args: ['name',] },],
    'value': [{ type: Input, args: ['value',] },],
    'placeholder': [{ type: Input, args: ['placeholder',] },],
    'initialsSize': [{ type: Input, args: ['initialsSize',] },],
    'clickOnAvatar': [{ type: Output },],
};

var AvatarModule = (function () {
    function AvatarModule() {
    }
    /**
     * @param {?} avatarConfig
     * @return {?}
     */
    AvatarModule.forRoot = function (avatarConfig) {
        return {
            ngModule: AvatarModule,
            providers: [{ provide: AVATAR_CONFIG, useValue: avatarConfig }]
        };
    };
    return AvatarModule;
}());
AvatarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpModule
                ],
                declarations: [
                    AvatarComponent
                ],
                providers: [SourceFactory, AvatarService],
                exports: [
                    AvatarComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
AvatarModule.ctorParameters = function () { return []; };

export { AvatarModule, AvatarComponent, SourceFactory, AvatarConfig, AvatarService, AVATAR_CONFIG };
